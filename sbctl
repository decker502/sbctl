#!/bin/bash
#
# MIT License
#
# Copyright (c) 2025 Kafka Liu
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

# sbctl - sing-box wrapper for macOS

CONFIG_DIR="$HOME/.sing_box"
CONFIG_FILE="$CONFIG_DIR/config.json"
SING_BOX_BIN="${SING_BOX_BIN:-sing-box}"   # 可通过环境变量指定 sing-box 路径
REMOTE_URL="${REMOTE_URL:-}"               # 必须通过环境变量传入

# 获取脚本所在目录（用于定位 ui 文件夹）
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
UI_DIR="$SCRIPT_DIR/ui"

# Clash API 配置
CLASH_API_PORT="${CLASH_API_PORT:-9090}"
CLASH_API_SECRET="${CLASH_API_SECRET:-}"

usage() {
    echo "用法: $0 [命令] [参数]"
    echo
    echo "命令:"
    echo "  fetch                       获取远程 config.json 并保存到 $CONFIG_FILE"
    echo "  list                        列出 config.json 中可用的代理名称"
    echo "  proxy <proxy_name>          启动 HTTP/SOCKS 代理模式 (需设置环境变量生效)"
    echo "  tun   <proxy_name> <proc...> 启动 TUN 模式，仅指定进程走代理，其他直连"
    echo "  mix   <proxy_name> <proc...> 混合模式：指定进程走 TUN，其他进程直连，同时保留 HTTP/SOCKS 代理功能"
    echo
    echo "示例:"
    echo "  $0 fetch"
    echo "  $0 list"
    echo "  $0 proxy \"HK-01\""
    echo "  $0 tun \"HK-01\" \"Google Chrome\" Telegram"
    echo "  $0 mix \"HK-01\" \"Google Chrome\" Telegram"
    echo
    echo "Web UI (yacd):"
    echo "  启动后访问 http://127.0.0.1:${CLASH_API_PORT}/ui 查看控制面板"
    echo "  可通过环境变量自定义:"
    echo "    CLASH_API_PORT   API 端口 (默认: 9090)"
    echo "    CLASH_API_SECRET 访问密码 (默认: 空)"
    echo
    exit 1
}

cmd_fetch() {
    mkdir -p "$CONFIG_DIR"
    echo "从 $REMOTE_URL 获取配置..."
    curl -fsSL "$REMOTE_URL" -o "$CONFIG_FILE" || {
        echo "获取配置失败"
        exit 1
    }
    echo "已保存到 $CONFIG_FILE"
}

cmd_list() {
    if [ ! -f "$CONFIG_FILE" ]; then
        echo "找不到配置文件: $CONFIG_FILE"
        exit 1
    fi
    jq -r '.outbounds[]?.tag // empty' "$CONFIG_FILE"
}

cmd_proxy() {
    if [ $# -lt 1 ]; then
        echo "缺少代理名称"
        usage
    fi
    local proxy_name="$1"

    if [ ! -f "$CONFIG_FILE" ]; then
        echo "找不到配置文件: $CONFIG_FILE"
        exit 1
    fi

    TMP_CONFIG="$(mktemp)"
    trap 'rm -f "$TMP_CONFIG"' EXIT

    # 移除 tun，仅保留 DNS，避免全部走流量。
    jq --arg name "$proxy_name" \
       --arg ui_dir "$UI_DIR" \
       --arg api_port "$CLASH_API_PORT" \
       --arg api_secret "$CLASH_API_SECRET" '
      .inbounds |= map(select(.type != "tun"))
      | .route.rules = [ { "protocol": "dns", "outbound": "dns" } ]
      | .route.final = $name
      | .experimental.clash_api = {
          "external_controller": ("127.0.0.1:" + $api_port),
          "external_ui": $ui_dir,
          "secret": $api_secret
        }
    ' "$CONFIG_FILE" > "$TMP_CONFIG"

    echo "使用代理 [$proxy_name] 启动 sing-box (HTTP模式)..."
    echo "注意: 只有设置 http_proxy/https_proxy/all_proxy 时才会生效"
    echo "Web UI: http://127.0.0.1:${CLASH_API_PORT}/ui"

    sudo "$SING_BOX_BIN" run -c "$TMP_CONFIG"
    rm -f "$TMP_CONFIG"
}

cmd_tun() {
    if [ $# -lt 2 ]; then
        echo "错误: 需要指定代理名称和至少一个进程正则/关键词"
        usage
    fi

    local proxy_name="$1"
    shift

    if [ ! -f "$CONFIG_FILE" ]; then
        echo "找不到配置文件: $CONFIG_FILE"
        exit 1
    fi

    # 保存进程列表供后台监控使用
    local proc_list=("$@")

    local proc_json="["
    first=true
    for proc in "$@"; do
        if [ "$first" = true ]; then first=false; else proc_json+=","; fi
        proc_json+="\"$proc\""
    done
    proc_json+="]"

    TMP_CONFIG="$(mktemp)"
    CGROUP_NAME="sbctl_proxy"
    CGROUP_PATH="/sys/fs/cgroup/$CGROUP_NAME"
    PROXY_PORT=12345
    MONITOR_PID=""
    KNOWN_PIDS_FILE="/tmp/sbctl_known_pids"

    # 使用 redirect 模式，配合 cgroup + iptables 只代理特定进程
    jq --arg name "$proxy_name" --argjson procs "$proc_json" \
       --arg ui_dir "$UI_DIR" \
       --arg api_port "$CLASH_API_PORT" \
       --arg api_secret "$CLASH_API_SECRET" \
       --argjson proxy_port "$PROXY_PORT" '
      .outbounds = (
        [.outbounds[] | select(.tag != "direct")] +
        [{ "type": "direct", "tag": "direct" }]
      )
      | .dns.servers = [
        { "tag": "localdns", "type": "udp", "server": "8.8.8.8", "server_port": 53 },
        { "tag": "proxydns", "type": "udp", "server": "1.1.1.1", "server_port": 53 }
      ]
      | .dns.rules = [
          { "outbound": "any", "server": "localdns" },
          { "query_type": ["A", "AAAA"], "server": "proxydns" }
        ]
      | .dns.final = "localdns"
      | del(.dns.fakeip)
      | del(.dns.independent_cache)
      # 使用 mixed 入站（HTTP + SOCKS5）
      | .inbounds = [
        {
          "type": "mixed",
          "tag": "mixed-in",
          "listen": "127.0.0.1",
          "listen_port": $proxy_port,
          "sniff": true
        },
        {
          "type": "redirect",
          "tag": "redirect-in",
          "listen": "127.0.0.1",
          "listen_port": ($proxy_port + 1),
          "sniff": true
        }
      ]
      | .route.rules = [
          { "protocol": "dns", "action": "hijack-dns" },
          { "process_path_regex": $procs, "outbound": $name }
        ]
      | .route.final = $name
      | .route.default_domain_resolver = "localdns"
      | del(.route.rule_set)
      | del(.ntp)
      | if .experimental.cache_file then .experimental.cache_file.store_fakeip = false else . end
      | .experimental.clash_api = {
          "external_controller": ("127.0.0.1:" + $api_port),
          "external_ui": $ui_dir,
          "secret": $api_secret
        }
    ' "$CONFIG_FILE" > "$TMP_CONFIG"

    # 后台进程监控函数 - 自动将新进程加入 cgroup
    start_process_monitor() {
        local procs=("$@")
        > "$KNOWN_PIDS_FILE"  # 清空已知 PID 文件

        while true; do
            for proc in "${procs[@]}"; do
                pids=$(pgrep -f "$proc" 2>/dev/null || true)
                for pid in $pids; do
                    # 检查是否已经在 cgroup 中
                    if ! grep -q "^$pid$" "$KNOWN_PIDS_FILE" 2>/dev/null; then
                        # 检查进程是否还存在
                        if [ -d "/proc/$pid" ]; then
                            echo "$pid" | sudo tee "$CGROUP_PATH/cgroup.procs" > /dev/null 2>&1 && \
                            echo "$pid" >> "$KNOWN_PIDS_FILE" && \
                            echo "[监控] 自动将进程 $pid ($proc) 加入代理组"
                        fi
                    fi
                done
            done
            sleep 2  # 每 2 秒检查一次
        done
    }

    setup_cgroup_proxy() {
        echo "正在设置 cgroup 和 iptables 规则..."

        # 创建 cgroup (cgroup2)
        if [ ! -d "$CGROUP_PATH" ]; then
            sudo mkdir -p "$CGROUP_PATH"
        fi

        # 获取 cgroup 的 classid
        CGROUP_ID=$(stat -c %i "$CGROUP_PATH" 2>/dev/null || echo "")

        # 清理旧规则
        sudo iptables -t nat -D OUTPUT -j SBCTL_OUTPUT 2>/dev/null || true
        sudo iptables -t nat -F SBCTL_OUTPUT 2>/dev/null || true
        sudo iptables -t nat -X SBCTL_OUTPUT 2>/dev/null || true

        # 创建新规则链
        sudo iptables -t nat -N SBCTL_OUTPUT 2>/dev/null || true

        # 本地地址不代理
        sudo iptables -t nat -A SBCTL_OUTPUT -d 127.0.0.0/8 -j RETURN
        sudo iptables -t nat -A SBCTL_OUTPUT -d 10.0.0.0/8 -j RETURN
        sudo iptables -t nat -A SBCTL_OUTPUT -d 172.16.0.0/12 -j RETURN
        sudo iptables -t nat -A SBCTL_OUTPUT -d 192.168.0.0/16 -j RETURN

        # 排除 root 用户的流量（sing-box 以 root 运行）
        sudo iptables -t nat -A SBCTL_OUTPUT -m owner --uid-owner 0 -j RETURN

        # 使用 cgroup 匹配，将流量重定向到代理端口
        sudo iptables -t nat -A SBCTL_OUTPUT -p tcp -m cgroup --path "$CGROUP_NAME" -j REDIRECT --to-ports $((PROXY_PORT + 1))

        # 应用规则到 OUTPUT 链
        sudo iptables -t nat -A OUTPUT -j SBCTL_OUTPUT

        # 将当前配置的进程加入 cgroup
        for proc in "$@"; do
            pids=$(pgrep -f "$proc" 2>/dev/null || true)
            for pid in $pids; do
                echo "$pid" | sudo tee "$CGROUP_PATH/cgroup.procs" > /dev/null 2>&1 || true
                echo "$pid" >> "$KNOWN_PIDS_FILE" 2>/dev/null || true
                echo "  已将进程 $pid ($proc) 加入代理组"
            done
        done
    }

    cleanup() {
        echo ""
        echo "正在清理..."
        # 停止后台监控进程
        if [ -n "$MONITOR_PID" ] && kill -0 "$MONITOR_PID" 2>/dev/null; then
            kill "$MONITOR_PID" 2>/dev/null || true
            wait "$MONITOR_PID" 2>/dev/null || true
        fi
        sudo iptables -t nat -D OUTPUT -j SBCTL_OUTPUT 2>/dev/null || true
        sudo iptables -t nat -F SBCTL_OUTPUT 2>/dev/null || true
        sudo iptables -t nat -X SBCTL_OUTPUT 2>/dev/null || true
        rm -f "$TMP_CONFIG" "$KNOWN_PIDS_FILE"
        echo "清理完成"
    }

    trap cleanup EXIT INT TERM

    echo "=== 启动进程级代理模式 ==="
    echo "代理节点: $proxy_name"
    echo "目标进程: ${proc_json}"
    echo "其他流量: 完全不受影响"
    echo "代理端口: $PROXY_PORT (HTTP/SOCKS5)"
    echo "Web UI: http://127.0.0.1:${CLASH_API_PORT}/ui"
    echo ""
    echo "✨ 已启用自动监控：新启动的目标进程会自动加入代理组"
    echo ""

    setup_cgroup_proxy "${proc_list[@]}"

    # 启动后台进程监控
    start_process_monitor "${proc_list[@]}" &
    MONITOR_PID=$!
    echo "后台监控已启动 (PID: $MONITOR_PID)"

    echo ""
    echo "启动 sing-box..."
    sudo "$SING_BOX_BIN" run -c "$TMP_CONFIG"
}

cmd_mix() {
    if [ $# -lt 2 ]; then
        echo "错误: 需要指定代理名称和至少一个进程正则/关键词"
        echo "用法: $0 mix <代理名称> <进程1> [进程2...]"
        exit 1
    fi

    local proxy_name="$1"
    shift 

    if [ ! -f "$CONFIG_FILE" ]; then
        echo "找不到配置文件: $CONFIG_FILE"
        exit 1
    fi

    local proc_json="["
    first=true
    for proc in "$@"; do
        if [ "$first" = true ]; then first=false; else proc_json+=","; fi
        proc_json+="\"$proc\""
    done
    proc_json+="]"

    TMP_CONFIG="$(mktemp)"
    trap 'rm -f "$TMP_CONFIG"' EXIT

    # === 核心逻辑 ===
    # 1. 清理旧的 tun (如果有)，保留 HTTP/SOCKS (mixed/http 等)，并追加新的 tun (带 tag: tun-in)
    # 2. 路由规则：
    #    a. DNS -> dns
    #    b. 命中进程正则 -> 代理节点
    #    c. 来源是 tun-in 但没命中正则 -> 直连 (防止误伤)
    #    d. Final (通常是 HTTP 端口来的流量) -> 代理节点
    
    jq --arg name "$proxy_name" --argjson procs "$proc_json" \
       --arg ui_dir "$UI_DIR" \
       --arg api_port "$CLASH_API_PORT" \
       --arg api_secret "$CLASH_API_SECRET" '
      .inbounds |= map(select(.type != "tun")) + [{
          "type": "tun",
          "tag": "tun-in",
          "inet4_address": ["172.19.0.1/30"],
          "auto_route": true,
          "stack": "system",
          "sniff": true
      }]
      | .route.rules = [
          { "protocol": "dns", "outbound": "dns" },
          { "process_path_regex": $procs, "outbound": $name },
          { "inbound": "tun-in", "outbound": "direct" }
        ]
      | .route.final = $name
      # 添加 Clash API 配置
      | .experimental.clash_api = {
          "external_controller": ("127.0.0.1:" + $api_port),
          "external_ui": $ui_dir,
          "secret": $api_secret
        }
    ' "$CONFIG_FILE" > "$TMP_CONFIG"

    echo "=== 启动 混合模式 (Mix Mode) ==="
    echo "代理节点: $proxy_name"
    echo "TUN 规则: 仅代理进程 ${proc_json}，其余 TUN 流量直连"
    echo "HTTP规则: 端口流量默认走代理"
    echo "Web UI: http://127.0.0.1:${CLASH_API_PORT}/ui"
    echo "需要管理员权限配置网络接口..."

    sudo ENABLE_DEPRECATED_TUN_ADDRESS_X=true "$SING_BOX_BIN" run -c "$TMP_CONFIG"
    
    rm -f "$TMP_CONFIG"
}

# ========== 主入口 ==========
cmd="${1:-}"
shift || true

case "$cmd" in
    fetch) cmd_fetch "$@" ;;
    list)  cmd_list "$@" ;;
    proxy) cmd_proxy "$@" ;;
    tun)   cmd_tun "$@" ;;
    mix)   cmd_mix "$@" ;;
    *)     usage ;;
esac
